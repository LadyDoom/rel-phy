[
  {
    "objectID": "projectile.html",
    "href": "projectile.html",
    "title": "Simulation de projectile",
    "section": "",
    "text": "Contexte\nExplications\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode en python (avec Glowscript)\nVoici le code correspondant :\n\nWeb VPython 3.2\n# Constantes\ngrille_dessinee = False\n#scene.lights = []\n#scene.ambient = color.gray(0.6) \nscalaireFleche = 50\ndt          = 0.01\ntailleSol   = 1000\ntrajFin     = False\npas=100\nG = 6.67430e-11\nr_planete = vec(0,0,0)\n\nboules_ind = []\n\n\nscene.width  = 600\nscene.height = 600\nscene.align  = 'left'\n\n# Objets créés/masqués à chaque lancement ; initialisés à None\nballe = forceAzimutale = forceCoriolis = forceCentrifuge = plancher = cible = cibleRouge = None\n\n\n#dictionnaire pour changer les couleurs\ncouleurs_force = {'coriolis':   color.green,'azimutal':   color.orange,'centrifuge': color.red}\n\nscene.up       = vector(0, 0, 1)\nscene.forward  = vector(0, -1, -0.3)\n\n\ntempAzimutal = 0\ntempCoriolis = 0\ntempCentrifuge = 0\n\ntabCoriolis = None\ncourbeCoriolis = None\ncourbeAzimutal = None\ncourbeCentrifuge = None\n\nvectAzimutal   = vec(0,0,0)\nvectCoriolis   = vec(0,0,0)\nvectCentrifuge = vec(0,0,0)\ncibleRougePos = 0\n\nt=0\nm = 1\nR = 2\nw = vec(0.0, 0.00, 0.005)       \nw_avant = w\nr = vec(1, 0, 0)*R\nr_avant = r\ng = vec(0, 0, -10)\n\n\n\n\n\n# Interface utilisateur\nscene.caption = \"\"\n\nRInput   = winput(bind=test, prompt=\" Rayon planète R (m) : \",   text=\"6.371e6\"); scene.append_to_caption(\"\\n\")\nMInput   = winput(bind=test, prompt=\" Masse planète M (kg) : \",  text=\"5.972e24\"); scene.append_to_caption(\"\\n\")\nomegaInput   = winput(bind=test, prompt=\" Vitesse ang. Ω (rad/s) : \", text=\"7.292e-5\"); scene.append_to_caption(\"\\n\")\n\nscene.append_to_caption(\"\\n\")\n\nlatInput = winput(bind=test, prompt=\" Colatitude labo φ (deg) : \", text=\"45\");      scene.append_to_caption(\"\\n\")\n\nposInput = winput(bind=test, prompt=\" Position init. (x,y,z) : \", text=\"10,10,0\"); scene.append_to_caption(\"\\n\")\nimpInput = winput(bind=test, prompt=\" Vitesse init. (u,ϕ,θ) : \",  text=\"52, 0, 45\"); scene.append_to_caption(\"\\n\")\n\nscene.append_to_caption(\"\\n\")\n\ncibleInput = winput(bind=test, prompt=\" Position cible (x,y,z) : \",text=\"20,20,0\"); scene.append_to_caption(\"\\n\")\n\nstartButton = button(text=\"Commencer\", bind=start)\n\n# Forces sup\nscene.append_to_caption(\"\\n\\n&lt;b&gt;Forces à inclure :&lt;/b&gt;\\n\")\ncbCentrifuge  = checkbox(bind=test,text=\"Centrifuge\",  checked=True);  scene.append_to_caption(\"  \")\ncbCoriolis    = checkbox(bind=test,text=\"Coriolis\",    checked=True);  scene.append_to_caption(\"   \")\ncbAzimutal    = checkbox(bind=test,text=\"Azimutale\",   checked=True);  scene.append_to_caption(\"   \")\n\n\nfor objet in (RInput, MInput, latInput, omegaInput,posInput, impInput,cibleInput, startButton):\n    objet.display=scene\n\n# Fonctions utilitaires\nfor obj in scene.objects:\n    if hasattr(obj, \"shininess\"):\n        obj.shininess = 0\n\ndef effacer():\n    global boules_ind, balle, forceAzimutale, forceCoriolis, forceCentrifuge, plancher, cible, cibleRouge\n    global tabCoriolis, courbeCoriolis, courbeAzimutal, courbeCentrifuge\n\n    # Balle principale\n    if balle is not None:\n        balle.clear_trail()\n        balle.visible = False\n\n    # Boules individuelles\n    for b, _ in boules_ind:\n        b.clear_trail()\n        b.visible = False\n    boules_ind.clear()        # vide la liste, inplace\n\n    for c in (courbeCoriolis, courbeAzimutal, courbeCentrifuge):\n        if c is not None:\n            c.delete()\n    courbeCoriolis = courbeAzimutal = courbeCentrifuge = None\n\n    # Flèches, sol, cibles\n    for obj in (forceAzimutale, forceCoriolis, forceCentrifuge, plancher, cible, cibleRouge):\n        if obj is not None:\n            obj.visible = False\n\n    if tabCoriolis is not None:\n        tabCoriolis.delete()\n        tabCoriolis = None\n        \n        \ndef spheACartOld(spherique):\n    \n    r = spherique.z\n    phi = spherique.y\n    theta = spherique.x\n    \n    x = r * sin(theta) * cos(phi)\n    y = r * sin(theta) * sin(phi)\n    z = r * cos(theta)\n    return vec(x, y, z)\n    \ndef spheACart(spherique):\n    # spherique = vec(u, phi, theta)\n    u     = spherique.x\n    phi   = spherique.y\n    theta = spherique.z\n    x = u * sin(theta) * cos(phi)\n    y = u * sin(theta) * sin(phi)\n    z = u * cos(theta)\n    return vec(x, y, z)\n\n\ndef dessinerGrille(pas):\n    demi  = tailleSol / 2\n    zlvl  = 0.51                  # légerement au-dessus du plancher\n    Laxe  = demi                  # longueur visible des axes\n    epais = 0.2                   # épaisseur des flèches\n\n    # ───── flèches cardinales ─────\n    # Est (+x) / Ouest (-x)\n    arrow(pos=vec(0,0,zlvl), axis=vec( Laxe, 0, 0), shaftwidth=epais, color=color.red)\n    arrow(pos=vec(0,0,zlvl), axis=vec(-Laxe, 0, 0), shaftwidth=epais, color=color.red)\n    label(pos=vec( Laxe+1, 0, zlvl), text='E',  box=False, height=12, color=color.red)\n    label(pos=vec(-Laxe-2,0, zlvl), text='O',  box=False, height=12, color=color.red)\n\n    # Nord (+y) / Sud (-y)\n    arrow(pos=vec(0,0,zlvl), axis=vec(0, Laxe, 0), shaftwidth=epais, color=color.green)\n    arrow(pos=vec(0,0,zlvl), axis=vec(0,-Laxe, 0), shaftwidth=epais, color=color.green)\n    label(pos=vec(0, Laxe+1, zlvl), text='N',  box=False, height=12, color=color.green)\n    label(pos=vec(0,-Laxe-2, zlvl), text='S',  box=False, height=12, color=color.green)\n\n    # Haut (+z)\n    arrow(pos=vec(0,0,0),    axis=vec(0,0,Laxe), shaftwidth=epais*10, color=color.blue)\n    label(pos=vec(0,0,Laxe+1), text='Haut', box=False, height=12, color=color.blue)\n\n    # ───── grille (lignes grises) ─────\n    k = 0.0\n    while k &lt;= demi + 1e-6:\n        # lignes verticales x = ±k\n        curve(pos=[vec( k, -demi, zlvl), vec( k,  demi, zlvl)], color=color.gray(0.7))\n        if k &gt; 1e-6:   # évite doublon, car k=0 déjà tracé\n            curve(pos=[vec(-k,-demi, zlvl), vec(-k, demi, zlvl)], color=color.gray(0.7))\n\n        # lignes horizontales y = ±k\n        curve(pos=[vec(-demi,  k, zlvl), vec( demi,  k, zlvl)], color=color.gray(0.7))\n        if k &gt; 1e-6:\n            curve(pos=[vec(-demi,-k, zlvl), vec( demi,-k, zlvl)], color=color.gray(0.7))\n\n        k += pas\n\n\n\ndef test():\n    pass\n\ndef parseVec(s):\n    return vec(*[float(x.strip()) for x in s.split(\",\")])\n\ndef afficherFleche(F):\n    if mag(F) &lt; 1e-9:\n        return vec(0,0,0)\n    return norm(F)*scalaireFleche\n\ndef ajouter_boule_force(force):\n    b = sphere(pos=positionInitiale,radius=0.06,color=couleurs_force[force],make_trail=True,trail_color=couleurs_force[force])\n    b.vitesse = impulsionInitiale\n    boules_ind.append((b, {force}))\n\ndef start(b):\n    global m, R, w, g, r_planete, cibleRougePos\n    global balle, forceAzimutale, forceCoriolis, forceCentrifuge\n    global positionInitiale, impulsionInitiale, plancher, trajFin\n    global cible, cibleRouge\n    global grille_dessinee\n    global t\n    global tabCoriolis, courbeCoriolis, courbeAzimutal, courbeCentrifuge\n\n\n    effacer()\n    t = 0.0\n    \n    \n    \n    # Tableaux des forces\n\n    tabCoriolis = graph(title='Magnitude de la force coriolis', xtitle='t', ytitle='N',align='right')\n\n    courbeCentrifuge = gcurve(graph=tabCoriolis, label='|F_centri|',color=couleurs_force['centrifuge'])\n\n    courbeCoriolis = gcurve(graph=tabCoriolis, label='|F_cor|',color=couleurs_force['coriolis'])\n\n\n    #tabAzimutal = graph(title='Magnitude de la force azimutal', xtitle='t', ytitle='N',align='right')\n\n    courbeAzimutal = gcurve(graph=tabCoriolis, label='|F_azi|',color=couleurs_force['azimutal'])\n\n    #tabCentrifuge = graph(title='Magnitude de la force centrifuge', xtitle='t', ytitle='N',align='right')\n\n    \n    # lecture des données\n    R = float(RInput.text)                 # rayon planète\n    M = float(MInput.text)                 # masse planète\n    lat_deg = 90-float(latInput.text)         # latitude du labo\n    omega   = float(omegaInput.text)           # vecteur de la rotation (rad/s)\n\n    lat_rad = radians(lat_deg)\n\n    # On construit w avec la latitude (longitude sera 0)\n    w = vec(0, omega*cos(lat_rad), omega*sin(lat_rad))\n    w_avant=w\n    w=majW(w)\n    # gravité de la planète\n    g_mag = G * M / R**2\n    g = vec(0, 0, -g_mag)\n\n    # position du laboratoire sur la terre\n    #r_planete = vec(R*cos(lat_rad), 0, R*sin(lat_rad))\n    r_planete = vec(0, 0, R)\n    \n\n\n\n\n    positionInitiale  = parseVec(posInput.text)\n    temp = parseVec(impInput.text)\n    \n    impulsionInitiale = spheACart(vec(temp.x,radians(temp.y),radians(temp.z)))\n\n\n    # Sol \n    plancher = box(pos=vec(0,0,0), length=tailleSol, height=tailleSol, width=1, color=color.white,opacity=0.4)\n    \n    if not grille_dessinee:\n        dessinerGrille(pas)\n        grille_dessinee = True\n    \n    # Création du trajet total\n    balle = sphere(pos=positionInitiale, radius=0.1, color=color.magenta, make_trail=True)\n    \n    \n    # Création des autres trajets\n\n    if cbCentrifuge.checked: \n        ajouter_boule_force('centrifuge')\n    if cbCoriolis.checked:  \n        ajouter_boule_force('coriolis')\n    if cbAzimutal.checked:   \n        ajouter_boule_force('azimutal')\n    \n    \n    \n    balle.vitesse = impulsionInitiale\n\n    forceAzimutale  = arrow(shaftwidth=1, color=color.orange)\n    forceCoriolis   = arrow(shaftwidth=1, color=color.green)\n    forceCentrifuge = arrow(shaftwidth=1, color=color.red)\n    \n\n\n    # Cible naive\n    x0, y0, z0      = balle.pos.x, balle.pos.y, balle.pos.z\n    vx0, vy0, vz0   = balle.vitesse.x, balle.vitesse.y, balle.vitesse.z\n    grav = abs(g.z)\n    temps = (vz0 + sqrt(vz0**2 + 2*grav*z0)) / grav\n    xf, yf = vx0*temps, vy0*temps\n    cible = sphere(pos=vec(x0+xf, y0+yf, 0), radius=5, color=color.blue)\n    \n    # Cible arbitraire\n    cibleRougePos = parseVec(cibleInput.text)\n    cibleRouge = sphere(pos=cibleRougePos, radius=5, color=color.red)\n\n\n    # On centre la caméra\n    scene.center   = (balle.pos+cible.pos)/2\n    scene.range = mag((balle.pos+cible.pos))\n\n    \n    trajFin = False\n    while not trajFin:\n        rate(150)\n        majVariables()\n        majVisuel()\n        t += dt\n    print(f\"Le projectile a touché le sol au point {balle.pos}\")\n    print(f\"La cible était au point {cibleRougePos}\")\n    distance = mag(balle.pos - cibleRougePos)\n    print(f\"Vous l'avez manqué de {distance:.2f} m\")\n    \ndef majW(w):\n    \n    return w\n\ndef majVariables():\n    global balle, trajFin, vectAzimutal, vectCoriolis, vectCentrifuge\n    global r, w, r_avant, w_avant, r_planete\n\n    r = r_planete + balle.pos  # le r \n    v = balle.vitesse\n    dw = (w - w_avant)/dt\n\n    vectAzimutal   = 0*m*cross(r, dw)\n    vectCoriolis   = 2*m*cross(v, w)\n    vectCentrifuge = m*cross(cross(w, r), w)\n\n    a = g + vectCoriolis + vectCentrifuge + vectAzimutal\n    balle.vitesse += a*dt\n    balle.pos     += balle.vitesse*dt\n    \n    \n    # Maj des autres trajets\n    for b, ens in boules_ind:\n        r_i  = r_planete + b.pos\n        v_i  = b.vitesse\n        dw_i = (w - w_avant)/dt\n\n        az_i  = 0*m*cross(r_i, dw_i)\n        cor_i = 2*m*cross(v_i, w)\n        cen_i = m*cross(cross(w, r_i), w)\n\n        a_i = g\n        if 'azimutal'   in ens:\n            a_i += az_i\n        if 'coriolis'   in ens: \n            a_i += cor_i\n        if 'centrifuge' in ens: \n            a_i += cen_i\n\n        b.vitesse += a_i*dt\n        b.pos     += b.vitesse*dt\n    \n    if balle.pos.z &lt;= 0:      # contact sol\n        trajFin = True\n\n    r_avant, w_avant = r, w\n\ndef majVisuel():\n    global tabCoriolis\n    tempAzimutal = mag(vectAzimutal)\n    tempCoriolis = mag(vectCoriolis)\n    tempCentrifuge = mag(vectCentrifuge)\n    \n    courbeCoriolis.plot(t, tempCoriolis)    \n    courbeAzimutal.plot(t, tempAzimutal)    \n    courbeCentrifuge.plot(t, tempCentrifuge)    \n    \n    scene.center   = (balle.pos+cible.pos)/2\n    scene.range = mag((balle.pos+cible.pos))\n    \n    forceAzimutale.axis  = afficherFleche(vectAzimutal)\n    forceCoriolis.axis   = afficherFleche(vectCoriolis)\n    forceCentrifuge.axis = afficherFleche(vectCentrifuge)\n    \n    \n\n    for fleche in (forceAzimutale, forceCoriolis, forceCentrifuge):\n        fleche.pos = balle.pos"
  },
  {
    "objectID": "michelsonmorley.html",
    "href": "michelsonmorley.html",
    "title": "Expérience de Michelson-Morley",
    "section": "",
    "text": "Contexte\nExplications\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode en python (avec Glowscript)\nVoici le code correspondant :\n\nWeb VPython 3.2\n\n# === Paramètres globaux ===\n\nscene.width = 600\nscene.height = 600\nscene.align = 'left'\n\nrefEther = False\nmodifEther = 6\n\norientation = 0\nlamb = 10e-9\nc = 1\nlongV = 20\nlongH = 20\ndeltaL = 0\n\nvEther = 0.0\nparticules = []\n\nposSource = vector(-10, 0, 0)\nposDetec = vector(0, -10, 0)\n\nfrequence = 0.25\nlongOnde = 1 / frequence\namplitude = 1\n\ndt = 0.01\ndx = 0.05\n\ncouleurs_fig = [color.black, color.gray(0.5), color.orange, color.green, color.magenta, color.cyan, color.red]\ncompteur_fig = 0\n\nsuiveurs = []\nondes = []\n\n# === Fonctions ===\n\nclass onde:\n    def __init__(self, debut, direction, couleur, amplitude, frequence=5, dephasage=0):\n        self.amplitude = amplitude\n        self.frequence = frequence\n        self.dephasage = dephasage\n        self.omega = 2 * pi * frequence\n        self.dir = direction\n        self.vertical = False\n        self.pos = vector(debut)\n        self.avance = 1\n        self.sphere = sphere(pos=debut, radius=0.1, color=couleur, make_trail=True, trail_type=\"curve\", interval=1, retain=1000)\n        self.k = 2 * pi * frequence / c\n\n    def updatekomega(self):\n        frequence_app = self.frequence / (1 - vEther * cos(orientation * pi))\n        self.omega = 2 * pi * frequence_app\n        self.k = 2 * pi * frequence_app\n\n    def get_amplitude(self, t):\n        self.updatekomega()\n        axis = vector(1, 0, 0) if not self.vertical else vector(0, 1, 0)\n        coord = dot(self.pos, axis)\n        return self.amplitude * sin(self.k * coord - self.avance * self.omega * t + self.dephasage)\n\n    def update(self, t):\n        amp = self.get_amplitude(t)\n        crete = vector(0, amp, 0) if not self.vertical else vector(amp, 0, 0)\n        self.sphere.pos = self.pos + crete\n        self.pos += self.dir\n\ndef majVitesse(ev):\n    global vEther\n    try:\n        vEther = float(eInput.text)\n        if vEther &lt; 0: vEther = 0\n        if vEther &gt; 1: vEther = 1\n    except:\n        vEther = 0\n    eTexteSlider.text = f\" {vEther:.1f} c\"\n    ventEther.axis = modifEther * vEther * vector(cos(orientation * pi), sin(orientation * pi), 0)\n    majInterference()\n    lancer_animation_onde()\n\ndef majOrientation(ev):\n    global orientation\n    try:\n        orientation = float(oeInput.text)\n        if orientation &lt; 0: orientation = 0\n        if orientation &gt; 2: orientation = 2\n    except:\n        orientation = 0\n    oeTexteSlider.text = f\" {orientation:.2f} Pi\"\n    direction = vector(cos(orientation * pi), sin(orientation * pi), 0)\n    ventEther.axis = modifEther * vEther * direction\n    majInterference()\n    lancer_animation_onde()\n\ndef majDeltaL(ev):\n    global deltaL, longH\n    try:\n        deltaL = int(bhInput.text)\n        if deltaL &lt; -5: deltaL = -5\n        if deltaL &gt; 5: deltaL = 5\n    except:\n        deltaL = 0\n    longH = longV + deltaL * (longOnde / 2)\n    bhTexteSlider.text = f\" {deltaL} λ/4 \"\n    miroirH.pos = vector(longH / 2, 0, 0)\n    majInterference()\n    lancer_animation_onde()\n\ndef ajoutParticules(nombre, taille):\n    global particules\n    particules.clear()\n    for _ in range(nombre):\n        pos = vector(random() * 30 - 15, random() * 30 - 15, random() * 2 - 1)\n        p = sphere(pos=pos, radius=taille, color=color.white, opacity=0.3)\n        particules.append(p)\n\ndef majParticules():\n    vitesse = 2 * ventEther.axis\n    for p in particules:\n        p.pos += vitesse * dt\n        if p.pos.x &gt; 15: p.pos.x = -15\n        if p.pos.x &lt; -15: p.pos.x = 15\n        if p.pos.y &gt; 15: p.pos.y = -15\n        if p.pos.y &lt; -15: p.pos.y = 15\n\ndef temps(L, orientation):\n    terme1 = 2 * L / c\n    terme2 = sqrt(1 - vEther ** 2 * sin(orientation * pi) ** 2)\n    terme3 = 1 - vEther ** 2\n    return terme1 * (terme2 / terme3)\n\ndef majInterference():\n    global courbe\n    courbe.delete()\n    d0 = abs(longH - longV)\n    alpha = 0.1\n    t1 = temps(longV, orientation + 1 / 2)\n    t2 = temps(longH, orientation)\n    delta_phi = (2 * pi * (t1 - t2) * c) / lamb\n    for i in range(0, 100):\n        courbe.plot(i, cos((2 * pi / 5) * (i * alpha + d0) + delta_phi) ** 2)\n\n\ndef dupliquerCourbe():\n    global compteur_fig\n    couleur = couleurs_fig[compteur_fig % len(couleurs_fig)]\n    compteur_fig += 1\n    courbe_snapshot = gcurve(color=couleur)\n    d0 = abs(longH - longV)\n    alpha = 0.1\n    t1 = temps(longV, orientation + 1 / 2)\n    t2 = temps(longH, orientation)\n    delta_phi = (2 * pi * (t1 - t2) * c) / lamb\n    for i in range(0, 100):\n        y = cos((2 * pi / 5) * (i * alpha + d0) + delta_phi) ** 2\n        courbe_snapshot.plot(i, y)\n\ndef animer_onde(onde1, onde2):\n    t = 0\n    while not ((onde1.pos - posDetec).mag &lt; 1 and (onde2.pos - posDetec).mag &lt; 1):\n        if abs(dot(onde1.pos, vector(1, 0, 0)) - longH / 2) &lt;= dx:\n            onde1.dir = -onde1.dir\n            onde1.avance = -onde1.avance\n        if abs(dot(onde1.pos, vector(1, 0, 0))) &lt;= dx and onde1.avance == -1:\n            onde1.vertical = True\n            onde1.dir = vector(0, -dx, 0)\n        if abs(dot(onde2.pos, vector(1, 0, 0))) &lt;= dx and not onde2.vertical:\n            onde2.vertical = True\n            onde2.dir = vector(0, dx, 0)\n        if abs(dot(onde2.pos, vector(0, 1, 0)) - longV / 2) &lt;= dx:\n            onde2.dir = vector(0, -dx, 0)\n            onde2.avance = -onde2.avance\n        t += dt\n        if (onde1.pos - posDetec).mag &gt; 1:\n            onde1.update(t)\n        if (onde2.pos - posDetec).mag &gt; 1:\n            onde2.update(t)\n\ndef lancer_animation_onde():\n    for o in ondes:\n        o.sphere.clear_trail()\n        o.sphere.visible = False\n    ondes.clear()\n    onde1 = onde(posSource, vector(dx, 0, 0), color.blue, amplitude, frequence)\n    onde2 = onde(posSource, vector(dx, 0, 0), color.red, amplitude, frequence)\n    ondes.append(onde1)\n    ondes.append(onde2)\n    animer_onde(onde1, onde2)\n\ndef boucle_particules():\n    while True:\n        rate(100)\n        majParticules()\n\n# === Interface ===\n\n# === Interface (Sliders au-dessus de la scène) ===\n\nwtext(text=\"&lt;b&gt;Vitesse par rapport à l'ether (entre 0 et 1)&lt;/b&gt;&lt;br&gt;\", pos=scene.caption_anchor )\neInput = winput(bind=majVitesse, text=\"0.0\", type=\"numeric\", pos=scene.caption_anchor )\neTexteSlider = wtext(text=\" c\", pos=scene.caption_anchor )\nwtext(text=\"&lt;br&gt;&lt;br&gt;\", pos=scene.pos=scene.caption_anchor )\n\nwtext(text=\"&lt;b&gt;Orientation de l'ether (entre 0 et 2)&lt;/b&gt;&lt;br&gt;\", pos=scene.caption_anchor )\noeInput = winput(bind=majOrientation, text=\"0.0\", type=\"numeric\", pos=scene.caption_anchor )\noeTexteSlider = wtext(text=\" Pi\", pos=scene.caption_anchor )\nwtext(text=\"&lt;br&gt;&lt;br&gt;\", pos=scene.caption_anchor )\n\nwtext(text=\"&lt;b&gt;Différence de longueur (entre -5 et 5)&lt;/b&gt;&lt;br&gt;\", pos=scene.caption_anchor )\nbhInput = winput(bind=majDeltaL, text=\"0\", type=\"numeric\", pos=scene.caption_anchor )\nbhTexteSlider = wtext(text=\" λ/4 \", pos=scene.caption_anchor )\nwtext(text=\"&lt;br&gt;&lt;br&gt;\", pos=scene.caption_anchor )\n\n\n# === Objets de la scène ===\n\nventEther = arrow(pos=vector(-longH / 2, longV / 2, 0),\n                  axis=vector(1, 0, 0),\n                  color=color.cyan,\n                  shaftwidth=0.3)\nsource = sphere(pos=posSource, color=color.red)\nmiroirH = box(pos=vector(longH / 2, 0, 0), size=vector(0.1, 4, 4), axis=vector(1, 0, 0), opacity=0.8)\nmiroirV = box(pos=vector(0, longV / 2, 0), size=vector(0.1, 4, 4), axis=vector(0, 1, 0), opacity=0.8)\nsplitteur = box(size=vector(0.1, 4, 4), axis=vector(1, -1, 0), opacity=0.8)\ndetecteur = box(pos=posDetec, size=vector(3, 2, 2), axis=vector(0, 1, 0), color=color.white)\n\n# === Franges d'interférence ===\n\ngraph1 = graph(title=\"Intensité normalisée selon la distance sur le détecteur\",\n               xtitle=\"Position sur l'écran (m)\", ytitle=\"I/I_max\",\n               width=600, height=400)\n\ngraph1.align='right'\n\ncourbe = gcurve(color=color.blue)\nbutton(bind=dupliquerCourbe, text=\"Garder en mémoire\",pos=scene.caption_anchor)\n\n# === Lancement initial ===\n\najoutParticules(20, 0.5)\nmajInterference()\nlancer_animation_onde()\nboucle_particules()"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Comment utiliser ce site",
    "section": "",
    "text": "Étudiants\nSuivez les instructions et explorez les simulations.\n\n\nEnseignants\nVous pouvez copier l’ensemble du projet dans votre GitHub personnel et le modifier selon vos besoins."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Accueil",
    "section": "",
    "text": "Ce site est une ressource éducative libre (REL) créée par Delphine Bouilly et Patrick Dufour, professeurs au département de physique de l’Université de Montréal. Les simulations ont été réalisées par André Garcia, étudiant en physique à l’Université de Montréal.\nMerci à Samuel Poitras et à Erika le Bourdais pour leur aide dans ce projet.\nMerci à Indiana Delsart, bibliothécaire, pour ses conseils et la mise en place du site.\nLa création de cette ressource a été permise grâce au financement de la FabriqueREL.\n\nL’ensemble du site est sous licence CC-BY. Pour citer cette ressource :\nAuteur/Autrice. (date). Titre. Université de Montréal. Licence CC-BY\n\n\n\n\n\n\n\n\n\n\n\n\n\nCe site a été développé avec Quarto et est hébergé sur GitHub.\nDes outils d’intelligence artificielle (ChatGPT-4.1 et Claude Sonnet 4.6) ont été utilisés comme assistance technique pour la conception Web et la mise en ligne.\nLe contenu pédagogique et les simulations ont été réalisés sans recours à une IA générative."
  },
  {
    "objectID": "minkowski.html",
    "href": "minkowski.html",
    "title": "Diagramme de Minkowski",
    "section": "",
    "text": "Contexte\nCette activité permet de …\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode en python (avec Glowscript)\nVoici le code correspondant :\n\nWeb VPython 3.2\n\n############### Variables globales\ncounter = 0\ntempVitesse = 0.5\nobjVitesse = tempVitesse\nmin_x = 0\nmax_x = 0\nhauteur = 0\nprofondeur =0\nécart = 0\nmodeAjout=True\n# Variables pour tracer une ligne entre clic et relâchement\ndebutLigne = None\nclicEnCours = False\n###############################################\nscene.visible=False\n#scene.background = vector(0.652, 0.791, 0.966)\nscene.background = color.black\nscene.align = 'left'\npointeurSouris = None\n\ntempDel=[]\ntempDelBase=[]\nobjetsMagenta = []\n\nfor obj in scene.objects:          # everything currently in the scene\n    if hasattr(obj, \"shininess\"):  # spheres, boxes, arrows, curves…\n        obj.shininess = 0\n\n# === Entrée utilisateur (interface initiale) ===\nscene.caption = \"\"\n\n\ntempTitre = wtext(text=\"&lt;b&gt;Paramètres&lt;/b&gt;&lt;br&gt;\", pos=scene.title_anchor)\n\n#wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\nmin_label = wtext(text=\" Min x: \", pos=scene.title_anchor)\nminInput = winput(bind=test,text=\"0\", type=\"numeric\", pos=scene.title_anchor)\n#wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor) \n\nmax_label = wtext(text=\" Max x: \", pos=scene.title_anchor)\nmaxInput = winput(bind=test,text=\"20\", type=\"numeric\", pos=scene.title_anchor)\n#wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\nh_label = wtext(text=\" Max y: \", pos=scene.title_anchor)\nhInput = winput(bind=test,text=\"20\", type=\"numeric\", pos=scene.title_anchor)\n#wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\np_label = wtext(text=\" Min y: \", pos=scene.title_anchor)\npInput = winput(bind=test,text=\"0\", type=\"numeric\", pos=scene.title_anchor)\n#wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\n\ne_label = wtext(text=\" Écart: \", pos=scene.title_anchor)\neInput = winput(bind=test,text=\"2\", type=\"numeric\", pos=scene.title_anchor)\n\nwtext(text=\"&lt;br&gt;&lt;br&gt;\", pos=scene.title_anchor)\n####################################################\n\n\ntempTag = wtext(text=\"&lt;b&gt;&lt;/b&gt;&lt;br&gt;\", pos=scene.title_anchor)\n\nv_label = wtext(text=\"Vitesse de l'observateur : \", pos=scene.title_anchor)\nsVitesse = slider(min=-0.99, max=0.99, value=0.5, step=0.01, length=200, bind=majVitesseSlider, pos=scene.title_anchor)\ntxtVitesse = wtext(text=\" (v = 0.5 c)\", pos=scene.title_anchor)\n\nwtext(text=\"&lt;br&gt;&lt;br&gt;\", pos=scene.title_anchor)\n\n\n\n\nstart_button = button(bind=lancer_diagramme,text=\"Créer le diagramme\", pos=scene.title_anchor)\nwtext(text=\"&lt;br&gt;&lt;br&gt;\", pos=scene.title_anchor)\n\n\n#####################################################################################################\ndef br():\n    wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\ndef creer_ui_secondaire():\n    global acheck, rcheck, bcheck, cMagenta\n    global sObjet, txtVitesseObjet\n    global x_label, xInput, ct_label, ctInput, x2_label, ct2_label, x2Input, ct2Input, tempTag\n    global ajoutBouton, bouton_supprimer, modeEntree\n    global boutonSegment\n\n\n    tempTag.text=\"&lt;b&gt;Vitesse de l'observateur&lt;/b&gt;&lt;br&gt;\"\n\n    wtext(text=\"&lt;b&gt;Affichages&lt;/b&gt;\", pos=scene.title_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\n    acheck = checkbox(bind=ajoutCheck, text=\"Ajouter des objets\", checked=True, pos=scene.title_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\n    rcheck = checkbox(bind=cacherRef, text=\"Afficher le référentiel en mouvement\", checked=True, pos=scene.title_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\n    bcheck = checkbox(bind=cacherRefBase, text=\"Afficher le référentiel stationnaire\", checked=True, pos=scene.title_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\n    cMagenta = checkbox(bind=retirerObjet, text=\"Afficher les objets\", checked=True, pos=scene.title_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.title_anchor)\n\n    wtext(text=\"&lt;b&gt;Vitesse de l'objet&lt;/b&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    #wtext(text=\"Vitesse de l'objet à placer :\", pos=scene.title_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    sObjet = slider(min=-1, max=1, value=0.5, length=200, bind=majObjVitesse, pos=scene.caption_anchor)\n    txtVitesseObjet = wtext(text=\" (v = 0.5 c)\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    wtext(text=\"&lt;b&gt; Ajouter un point par coordonnées&lt;/b&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    x_label = wtext(text=\" x :    \", pos=scene.caption_anchor)\n    xInput  = winput(bind=test, type=\"numeric\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    ct_label = wtext(text=\" ct :   \", pos=scene.caption_anchor)\n    ctInput  = winput(bind=test, type=\"numeric\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    x2_label = wtext(text=\" x2 :  \", pos=scene.caption_anchor)\n    x2Input  = winput(bind=test, type=\"numeric\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    ct2_label = wtext(text=\" ct2 : \", pos=scene.caption_anchor)\n    ct2Input  = winput(bind=test, type=\"numeric\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    ajoutBouton = button(text=\"Ajouter le point\", bind=ajouter_point_manuellement, pos=scene.caption_anchor)\n\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n    \n    boutonSegment = button(text=\"Tracer segment\", bind=ajouter_segment_manuellement, pos=scene.caption_anchor)\n\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    \n    bouton_supprimer = button(text=\"Supprimer le dernier élément\", bind=supprimer_dernier_objet, pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n    modeEntree = checkbox(bind=changer_mode_entree,\n                          text=\"Entrée dans le référentiel en mouvement (x', ct')\",\n                          checked=False,\n                          pos=scene.caption_anchor)\n    wtext(text=\"&lt;br&gt;\", pos=scene.caption_anchor)\n\n\ndef supprimer_dernier_objet(b):\n    if len(objetsMagenta) &gt;= 2:\n        objetsMagenta[-1].visible = False\n        objetsMagenta[-2].visible = False\n        objetsMagenta.pop()\n        objetsMagenta.pop()\n\ndef changer_mode_entree(ev):\n    global x_label,ct_label,x2_label,ct2_label\n    if ev.checked:\n        x_label.text = \" x' :    \"\n        ct_label.text = \" ct' :   \"\n        x2_label.text = \" x2' :  \"\n        ct2_label.text = \" ct2' : \"\n    else:\n        x_label.text = \" x :    \"\n        ct_label.text = \" ct :   \"\n        x2_label.text = \" x2 :  \"\n        ct2_label.text = \" ct2 : \"\n# === Initialisation des flèches ===\ndef ajouter_segment_manuellementt(b):\n    global x2_label, x2Input, ct2_label, ct2Input\n\n    try:\n        # Lecture des deux points\n        x1  = float(xInput.text)\n        ct1 = float(ctInput.text)\n        x2  = float(x2Input.text)\n        ct2 = float(ct2Input.text)\n    except ValueError:\n        print(\"Entrées invalides.\")\n        return\n\n    p1 = coord_vers_vec(x1,  ct1)\n    p2 = coord_vers_vec(x2,  ct2)\n\ndef ajouter_segment_manuellement(b):\n    try:\n        x1  = float(xInput.text)\n        ct1 = float(ctInput.text)\n        x2  = float(x2Input.text)\n        ct2 = float(ct2Input.text)\n    except:\n        print(\"Entrées invalides.\")\n        return\n\n    p1 = coord_vers_vec(x1, ct1)\n    p2 = coord_vers_vec(x2, ct2)\n\n    # tracer directement le segment (2 points suffisent)\n    seg = curve(pos=[p1, p2], radius=0.06, color=color.magenta)\n    objetsMagenta.append(seg)\n\n    # petites lignes d’univers translucides au long du segment (optionnel)\n    n = 5\n    direction = norm(vec(objVitesse, 1, 0))\n    for i in range(n + 1):\n        t = i / n\n        point = p1 * (1 - t) + p2 * t\n        cyl = cylinder(pos=point, axis=direction * 20, radius=0.8, color=color.magenta, opacity=0.15)\n        objetsMagenta.append(cyl)\n\n\n    # revoir TODO\n    ligne = curve(radius=0.05, color=color.magenta)\n    objetsMagenta.append(ligne)\n\n    n = 5\n    for i in range(n + 1):\n        t = i / n\n        point = p1 * (1 - t) + p2 * t\n        ligne.append(pos=point)\n\n        direction = norm(vec(objVitesse, 1, 0))\n        cyl = cylinder(pos=point, axis=direction * 20,\n                       radius=1, color=color.magenta, opacity=0.1)\n        objetsMagenta.append(cyl)\n\ndef coord_vers_vec(x, ct):\n    \"\"\"Retourne un vec(x,ct,0) ou la projection (x',ct') selon modeEntree.\"\"\"\n    if modeEntree.checked:\n        u_xp  = norm(vec(1 / tempVitesse, 1, 0))\n        u_ctp = norm(vec(    tempVitesse, 1, 0))\n        return x * u_xp + ct * u_ctp\n    else:\n        return vec(x, ct, 0)\n\n\ndef ajouter_point_manuellement(b):\n    try:\n        x = float(xInput.text)\n        ct = float(ctInput.text)\n\n        if modeEntree.checked:\n            # Mode (x', ct') — projection géométrique\n            u_xp = norm(vec(1 / tempVitesse, 1, 0))\n            u_ctp = norm(vec(tempVitesse, 1, 0))\n            position = x * u_xp + ct * u_ctp\n        else:\n            position = vec(x, ct, 0)\n\n        sph = sphere(pos=position, radius=0.3, color=color.magenta)\n        objetsMagenta.append(sph)\n\n        direction = norm(vec(objVitesse, 1, 0))\n        cyl = cylinder(pos=position, axis=direction * 18, color=color.red, radius=0.07)\n        objetsMagenta.append(cyl)\n    except ValueError:\n        print(\"Entrées invalides.\")\n\n\n\n\ndef retirerObjet(ev):\n    if ev.checked:\n        for o in objetsMagenta:\n            o.visible = True\n    else:\n        for o in objetsMagenta:\n            o.visible = False\n            \ndef cacherRef(ev):\n    if ev.checked==False:\n        for elem in tempDel:\n            elem.visible=False\n    else:\n        dessiner_obv(min_x, max_x, hauteur, écart)\n\ndef cacherRefBase(ev):\n    if ev.checked==False:\n        for elem in tempDelBase:\n            elem.visible=False\n    else:\n        dessiner_plan_cartesien(min_x, max_x, hauteur, écart)\n\n\ndef majObjVitesse():\n    global objVitesse\n    objVitesse=sObjet.value\n    txtVitesseObjet.text = \" (v = \" + str(round(objVitesse, 2)) + \" c)\"\n\ndef majVitesseSlider():\n    global tempVitesse\n    tempVitesse = sVitesse.value\n    txtVitesse.text = \" (v = \" + str(round(tempVitesse, 3)) + \" c)\"\n    \n    for elem in tempDel:\n        elem.visible = False\n    dessiner_obv(min_x, max_x, hauteur, écart)\n\ndef majVitesse(ev):\n    global tempVitesse\n    tempVitesse =float(vInput.text)\n    for elem in tempDel:\n        elem.visible=False\n    #print(tempDel)\n    dessiner_obv(min_x, max_x, hauteur, écart)\n\ndef decomposer_position(evt):\n    global pointeurSouris\n    # Projeter la position de la souris sur le plan XY\n    position = scene.mouse.project(normal=vec(0, 0, 1), point=vec(0, 0, 0))\n    if position is None:\n        return\n\n    position.z = 0.2\n    pointeurSouris.pos = position\n    pointeurSouris.visible = True\n\n    # Mettre à jour la flèche x (de (0,0) à (x,0))\n    fleche_x.pos = vec(0, 0, 0)\n    fleche_x.axis = vec(position.x, 0, 0)\n\n    # Mettre à jour la flèche y (de (0,0) à (0,y))\n    fleche_y.pos = vec(0, 0, 0)\n    fleche_y.axis = vec(0, position.y, 0)\n    \n    temp = (position.y-position.x*tempVitesse)/(1/tempVitesse-tempVitesse)\n    fleche_yobv.pos = vec(0, 0, 0)\n    fleche_yobv.axis = vec(temp,temp*1/tempVitesse , 0)\n\n    \n\n    temp = (position.y-position.x*1/tempVitesse)/(tempVitesse-1/tempVitesse)\n    fleche_xobv.pos = vec(0, 0, 0)\n    fleche_xobv.axis = vec(temp,temp*tempVitesse , 0)\n    \n\n\n# === Dessin du plan cartésien ===\n\ndef test():\n    pass\n\ndef dessiner_plan_cartesien(min_x, max_x, hauteur, écart):\n    scene.center = vec((min_x + max_x) / 2, (hauteur+profondeur) / 2, 0)\n    \n    #Axes\n    arrow(pos=vec(0, 0, 0), axis=vec(min_x, 0, 0), shaftwidth=0.08, color=color.white)\n    arrow(pos=vec(0, 0, 0), axis=vec(max_x, 0, 0), shaftwidth=0.08, color=color.white)\n    arrow(pos=vec(0, 0, 0), axis=vec(0, hauteur, 0), shaftwidth=0.08, color=color.white)\n\n    label(pos=vec(max_x, 0, 0), text=\"x\", xoffset=10, height=12, box=False, color=color.red)\n    label(pos=vec(0, hauteur, 0), text=\"ct\", yoffset=10, height=12, box=False, color=color.green)\n    \n    \n    #Lignes verticales\n    x = 0\n    while x &lt; max_x:\n        t=cylinder(pos=vec(x, 0, 0), axis=vec(0, hauteur, 0), radius=0.05, color=color.gray(0.8))\n        tempDelBase.append(t)\n        if profondeur &lt;0:\n            t=cylinder(pos=vec(x, 0, 0), axis=vec(0, -hauteur, 0), radius=0.05, color=color.gray(0.8))\n            tempDelBase.append(t)\n\n        \n        x += écart\n    x = -écart\n    while x &gt; min_x:\n        t=cylinder(pos=vec(x, 0, 0), axis=vec(0, hauteur, 0), radius=0.05, color=color.gray(0.8))\n        tempDelBase.append(t)\n        if profondeur &lt;0:\n            t=cylinder(pos=vec(x, 0, 0), axis=vec(0, -hauteur, 0), radius=0.05, color=color.gray(0.8))\n            tempDelBase.append(t)\n            x -= écart\n        \n    y = 0\n\n    while y &lt;= hauteur:\n        t=cylinder(pos=vec(0, y, 0), axis=vec(max_x - 2, 0, 0), radius=0.05, color=color.gray(0.8))\n        tempDelBase.append(t)\n        t=cylinder(pos=vec(0, y, 0), axis=vec(min_x + 2, 0, 0), radius=0.05, color=color.gray(0.8))\n        tempDelBase.append(t)\n\n        y += écart\n    \n    if profondeur &lt;0:\n        y = -écart\n        while y &gt;= profondeur - 1:\n            t=cylinder(pos=vec(0, y, 0), axis=vec(max_x - 2, 0, 0), radius=0.05, color=color.gray(0.8))\n            tempDelBase.append(t)\n            t=cylinder(pos=vec(0, y, 0), axis=vec(min_x + 2, 0, 0), radius=0.05, color=color.gray(0.8))\n            tempDelBase.append(t)\n        \n            y -= écart\n\ndef getAngle(vit):\n    return pi/2-atan(vit)\n\ndef dessiner_obv(min_x, max_x, hauteur, écart):\n    scene.center = vec((min_x + max_x) / 2, hauteur / 2, 2)\n    \n\n    \n    t=arrow(pos=vec(0, 0, 0), axis=norm(vec((1/tempVitesse), 1, 0))*max_x/cos(pi/2-getAngle(tempVitesse)), shaftwidth=0.1, color=color.purple)\n    tempDel.append(t)\n    \n    t=arrow(pos=vec(0, 0, 0), axis=norm(vec(tempVitesse, 1, 0))*hauteur/cos(getAngle(1/tempVitesse)), shaftwidth=0.1, color=color.purple)\n    tempDel.append(t)\n    \n    \n    \n    if profondeur &lt;0:\n        t=arrow(pos=vec(0, 0, 0), axis=norm(vec(-(1/tempVitesse), -1, 0))*max_x/cos(pi/2-getAngle(tempVitesse)), shaftwidth=0.1, color=color.purple)\n        tempDel.append(t)\n        t=arrow(pos=vec(0, 0, 0), axis=norm(vec(-tempVitesse, -1, 0))*hauteur/cos(getAngle(1/tempVitesse)), shaftwidth=0.1, color=color.purple)\n        tempDel.append(t)\n    \n    t=label(pos=norm(vec((1/tempVitesse), 1, 0))*max_x/cos(pi/2-getAngle(tempVitesse)), text=\"x'\", xoffset=10, height=12, box=False, color=color.red)\n    tempDel.append(t)\n    \n    t=arrow(pos=vec(0, 0, 0), axis=norm(vec(tempVitesse, 1, 0))*hauteur/cos(getAngle(1/tempVitesse)), shaftwidth=0.1, color=color.purple)\n    tempDel.append(t)\n    \n    if tempVitesse&gt;0:\n        t=label(pos=norm(vec(tempVitesse, 1, 0))*hauteur/cos(getAngle(1/tempVitesse)), text=\"ct'\", yoffset=10, height=12, box=False, color=color.green)\n        tempDel.append(t)\n        \n    else:\n        t=label(pos=norm(vec(tempVitesse, 1, 0))*hauteur/cos(getAngle(1/tempVitesse)), text=\"ct'\", yoffset=10, height=12, box=False, color=color.green)\n        tempDel.append(t)\n        \n    \n    #Lignes verticales\n    x = 0\n    while x &lt; max_x and (x*tempVitesse)&lt;max_x/2:\n\n        if tempVitesse &lt;0:\n            t=cylinder(pos=vec(-x, -x*(tempVitesse), 0), axis=norm(vec((tempVitesse), 1, 0))*hauteur, radius=0.05, color=color.orange)\n        else:\n            t=cylinder(pos=vec(x, x*(tempVitesse), 0), axis=norm(vec((tempVitesse), 1, 0))*hauteur, radius=0.05, color=color.orange)  \n        tempDel.append(t)\n        if profondeur &lt;0:\n            \n            if tempVitesse &lt;0:\n                t=cylinder(pos=vec(-x, -x*(tempVitesse), 0), axis=norm(vec( (tempVitesse),1, 0))*-hauteur, radius=0.05, color=color.orange)\n            else:\n                t=cylinder(pos=vec(x, x*(tempVitesse), 0), axis=norm(vec((tempVitesse), 1, 0))*hauteur, radius=0.05, color=color.orange)    \n            tempDel.append(t)\n        x += écart\n    x = -écart\n    #while x &gt; min_x:\n     #   cylinder(pos=vec(x, 0, 0), axis=norm(vec(-tempVitesse, 1, 0))*18, radius=0.05, color=color.gray(0.8))\n      #  x -= écart\n        \n    y = 0\n\n    while y &lt;= hauteur - 1 and (y*tempVitesse)&lt;hauteur/2:\n        t=cylinder(pos=vec(y*tempVitesse, y, 0), axis=norm(vec((1/tempVitesse), 1, 0))*max_x, radius=0.05, color=color.orange)\n        tempDel.append(t)\n        if profondeur &lt;0:\n            t=cylinder(pos=vec(-y*tempVitesse, -y, 0), axis=norm(vec( (1/tempVitesse),1, 0))*-max_x, radius=0.05, color=color.orange)\n            tempDel.append(t)\n        y += écart\n        \n    \n\n# === Bouton de démarrage ===\ndef lancer_diagramme(bouton):\n    global vslider,min_x,max_x,hauteur,écart,profondeur\n    min_x = int(minInput.text)\n    max_x = int(maxInput.text)\n    hauteur = int(hInput.text)\n    profondeur = int(pInput.text)\n    écart = float(eInput.text)\n\n    dessiner_plan_cartesien(min_x, max_x, hauteur, écart)\n    dessiner_obv(min_x, max_x, hauteur, écart)\n        \n    # Cacher les éléments de l'interface\n    for w in (tempTitre, min_label, minInput, max_label, maxInput,h_label, hInput, p_label, pInput, e_label, eInput,v_label, start_button):\n        w.delete()\n\n    scene.visible = True\n    scene.caption = \"&lt;b&gt; Diagramme de Minkowski &lt;/b&gt;\"\n    #afficher nouveaux boutons\n    creer_ui_secondaire()\n\n\n\n\n# Ajoute un objet dans le plan\ndef ajoutObjet(evt):\n    global counter\n    counter += 1\n    posObjet = scene.mouse.project(normal=vec(0, 0, 1), point=vec(0, 0, 0))\n\n    t =sphere(pos=posObjet, radius=0.3, color=color.magenta)\n    objetsMagenta.append(t)\n    t =cylinder(pos=posObjet, axis=norm(vec(objVitesse, 1, 0))*18, color=color.red,radius=0.07)\n    objetsMagenta.append(t)\ndef ajoutObjetLarge():\n    print(\"objet large\")\n    \ndef ajoutCheck(ev):\n    global modeAjout\n    modeAjout = ev.checked\n    \ndef redirection():\n    if modeAjout:\n        ajoutObjetLarge()\n    else:\n        decomposer_position()\n\ndef redirection2():\n    global debutLigne, clicEnCours\n    if modeAjout:\n        debutLigne = scene.mouse.project(normal=vec(0, 0, 1), point=vec(0, 0, 0))\n        clicEnCours = True\n    else:\n        decomposer_position()\n        \n    \n    \ndef relacherSouris(evt):\n    global debutLigne, clicEnCours\n    if modeAjout and clicEnCours and debutLigne is not None:\n        finLigne = scene.mouse.project(normal=vec(0, 0, 1), point=vec(0, 0, 0))\n        if finLigne is not None:\n            distance = mag(finLigne - debutLigne)\n            if distance &lt; 0.2:\n                # Clic court → ajout d’un objet\n                ajoutObjet(evt)\n            else:\n                # Clic-glisser → tracer une ligne avec lignes d’univers\n                ligne = curve(radius=0.05, color=color.magenta)\n                objetsMagenta.append(ligne)\n\n                n = 5\n                for i in range(n + 1):\n                    t = i / n\n                    point = debutLigne * (1 - t) + finLigne * t\n                    ligne.append(pos=point)\n                    direction = norm(vec(objVitesse, 1, 0))\n                    cyl=cylinder(pos=point, axis=direction * 20, radius=1, color=color.magenta, opacity=0.1)\n                    objetsMagenta.append(cyl)\n\n    debutLigne = None\n    clicEnCours = False\n\n\n############### Programme\n\npointeurSouris = sphere(\n    pos=vec(0, 0, 0),\n    radius=0.25,           \n    color=color.yellow,\n    shininess=0,\n    visible=False\n)\n\n\nscene.bind('mousemove', redirection)\nscene.bind('mousedown', redirection2)\nscene.bind(\"mouseup\", relacherSouris)\n\n\n\nfleche_x = arrow(color=color.red, shaftwidth=0.15)\nfleche_y = arrow(color=color.green, shaftwidth=0.15)\n\nfleche_xobv = arrow(color=color.red, shaftwidth=0.15)\nfleche_yobv = arrow(color=color.green, shaftwidth=0.15)"
  }
]